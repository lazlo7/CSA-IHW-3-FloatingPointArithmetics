Смагин Максим Сергеевич, БПИ-212  

# 4 балла.

Используется стандарт C11 (`-std=c11`).  

Тестовое покрытие: 
|  Ввод a  |  Ввод b  | Результат prog-orig | Результат prog-mod |                   Комментарий                  |
|----------|----------|---------------------|--------------------|------------------------------------------------|
|  12.345  |  67.891  |     691.537904      |     691.537904     |       а меньше, чем b; оба положительные       |
|    -2    |    -1    |     -2.504630       |      -2.504630     |       а меньше, чем b; оба отрицательные       |
|  13.37   |  13.37   |      0.000000       |      0.000000      |           а равно b; оба положительные         |
|  -13.37  |  -13.37  |     -0.000000       |     -0.000000      |           а равно b; оба отрицательные         |
| 1.020304 | 1.020303 |    Error: a <= b    |    Error: a <= b   |a больше, чем b -> ошибка и завершение программы|
|  -10.1   |   20.2   |     -288.780000     |     -288.780000    |       a меньше, чем b; а отрицательное         |
|   3478   |     0    |    Error: a <= b    |    Error: a <= b   |      а больше, чем b; b = 0 -> ошибка          |
|  -5.555  |     0    |   Error: a, b != 0  |  Error: a, b != 0  |     b = 0 -> ошибка и завершение программы     |
|     0    |   12.34  |   Error: a, b != 0  |  Error: a, b != 0  |     a = 0 -> ошибка и завершение программы     | 

Представленные тесты покрывают как типичные входные данные, так и краевые случаи (верхняя граница меньше нижней границы, b = 0 и т. д.).  
Результаты тестов эквивалентны для обеих программ.  
На основании проведенных тестов можно утверждать, что программы работают одинаково корректно.  

Используемые опции компиляции:
- `-masm=intel` для intel синтаксиса
- `-std=c11` используем стандарт C11
- `-fno-asynchronous-unwind-tables` unwind table создается только на границах вызовов
- `-fcf-protection=none` убираем генерацию лишних инструкций, поддерживающих CET (Control Flow Execution)

# 5 баллов.

Используется решение на 4 балла.  
В реализованной программе на C уже используются функции с передачей данных через параметры и локальные переменные.  

При передаче фактических параметров используются следующие соглашения (для double, xmm - 128-битный регистр):
- xmm0: первый аргумент/возвращаемое значение
- xmm1: второй аргумент
- xmm2: третий аргумент

Напишем комментарии к программе, пользуясь данными соглашениями.

# 6 баллов.
Попробуем (максимально) использовать регистры для решения задачи:
- func:
    - double a:  -8[rbp] -> xmm0
    - double b: -16[rbp] -> xmm1
    - double x: -24[rbp] -> xmm2
- simpson_approximate:
    - double a:  -8[rbp] -> xmm4
    - double b: -16[rbp] -> xmm5

В long режиме (64-битном режиме) есть 16 xmm регистров (xmm0, ..., xmm15). 
Дополнительные заметки по использованию регистров можно найти в комментариях исходного кода.  

Проверим корректность программы с помощью тестов.
Тестовое покрытие:
|  Ввод a  |  Ввод b  | Результат prog-orig | Результат prog-mod |                   Комментарий                  |
|----------|----------|---------------------|--------------------|------------------------------------------------|
|  12.345  |  67.891  |     691.537904      |     691.537904     |       а меньше, чем b; оба положительные       |
|    -2    |    -1    |     -2.504630       |      -2.504630     |       а меньше, чем b; оба отрицательные       |
|  13.37   |  13.37   |      0.000000       |      0.000000      |           а равно b; оба положительные         |
|  -13.37  |  -13.37  |     -0.000000       |     -0.000000      |           а равно b; оба отрицательные         |
| 1.020304 | 1.020303 |    Error: a <= b    |    Error: a <= b   |a больше, чем b -> ошибка и завершение программы|
|  -10.1   |   20.2   |     -288.780000     |     -288.780000    |       a меньше, чем b; а отрицательное         |
|   3478   |     0    |    Error: a <= b    |    Error: a <= b   |      а больше, чем b; b = 0 -> ошибка          |
|  -5.555  |     0    |   Error: a, b != 0  |  Error: a, b != 0  |     b = 0 -> ошибка и завершение программы     |
|     0    |   12.34  |   Error: a, b != 0  |  Error: a, b != 0  |     a = 0 -> ошибка и завершение программы     | 

Видно, что результаты тестов эквивалентны результатам тестов, проведенных выше.  
На основании проведенных тестов, можно утверждать, что программа работает корректно.  

Размеры программ:
|   Программа\Размеры  | Число строк кода (SLOC) | Размер исполняемого файла |
|----------------------|-------------------------|---------------------------|
|     prog-orig.S      |           197           |         17048 байт        |
|      prog-mod.S      |           272           |         16848 байт        |

В сравнении по числу строк кода используем SLOC (Source Lines Of Code), т. к. в мод. версии есть комментарии и пустые строки.  
Для подсчета SLOC использовалась утилита `cloc`.  
Для получения чистой версии не использовались лишние флаги компиляции, см. `prog-raw` в `./src/Makefile`.
Использование различных флагов, которые убирают макросы и ручной рефакторинг ассемблерного кода позволил сократить SLOC на ~ 28%, при этом изменение размера исполняемого файла незначительно.  